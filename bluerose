#!/usr/bin/env python

import chess
import chess.polyglot
import threading
import time
import sys


MAX_SCORE = 10000
MOVES_TO_ENDGAME = 25

ttDEPTH, ttFLAG, ttVALUE = 0, 1, 2
ttEXACT, ttLOWERBOUND, ttUPPERBOUND = 0, 1, 2
TRANSPOSITION_TABLE_SIZE = 0x1000000

# [King (end game), Pawn, Knight, Bishop, Rook, Queen, King]
PIECE_VALUES = [0, 100, 320, 330, 500, 900, 0]

POSITION_VALUES = [
    # King (end game)
    [
    -50,-40,-30,-20,-20,-30,-40,-50,
    -30,-20,-10,  0,  0,-10,-20,-30,
    -30,-10, 20, 30, 30, 20,-10,-30,
    -30,-10, 30, 40, 40, 30,-10,-30,
    -30,-10, 30, 40, 40, 30,-10,-30,
    -30,-10, 20, 30, 30, 20,-10,-30,
    -30,-30,  0,  0,  0,  0,-30,-30,
    -50,-30,-30,-30,-30,-30,-30,-50,
    ],
    # Pawn
    [
    0,  0,  0,  0,  0,  0,  0,  0,
    50, 50, 50, 50, 50, 50, 50, 50,
    10, 10, 20, 30, 30, 20, 10, 10,
     5,  5, 10, 25, 25, 10,  5,  5,
     0,  0,  0, 20, 20,  0,  0,  0,
     5, -5,-10,  0,  0,-10, -5,  5,
     5, 10, 10,-20,-20, 10, 10,  5,
     0,  0,  0,  0,  0,  0,  0,  0,
     ],
    # Knight
    [
    -50,-40,-30,-30,-30,-30,-40,-50,
    -40,-20,  0,  0,  0,  0,-20,-40,
    -30,  0, 10, 15, 15, 10,  0,-30,
    -30,  5, 15, 20, 20, 15,  5,-30,
    -30,  0, 15, 20, 20, 15,  0,-30,
    -30,  5, 10, 15, 15, 10,  5,-30,
    -40,-20,  0,  5,  5,  0,-20,-40,
    -50,-40,-30,-30,-30,-30,-40,-50,
    ],
    # Bishop
    [
    -20,-10,-10,-10,-10,-10,-10,-20,
    -10,  0,  0,  0,  0,  0,  0,-10,
    -10,  0,  5, 10, 10,  5,  0,-10,
    -10,  5,  5, 10, 10,  5,  5,-10,
    -10,  0, 10, 10, 10, 10,  0,-10,
    -10, 10, 10, 10, 10, 10, 10,-10,
    -10,  5,  0,  0,  0,  0,  5,-10,
    -20,-10,-10,-10,-10,-10,-10,-20,
    ],
    # Rook
    [
     0,  0,  0,  0,  0,  0,  0,  0,
     5, 10, 10, 10, 10, 10, 10,  5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
     0,  0,  0,  5,  5,  0,  0,  0,
    ],
    # Queen
    [
    -20,-10,-10, -5, -5,-10,-10,-20,
    -10,  0,  0,  0,  0,  0,  0,-10,
    -10,  0,  5,  5,  5,  5,  0,-10,
     -5,  0,  5,  5,  5,  5,  0, -5,
      0,  0,  5,  5,  5,  5,  0, -5,
    -10,  5,  5,  5,  5,  5,  0,-10,
    -10,  0,  5,  0,  0,  0,  0,-10,
    -20,-10,-10, -5, -5,-10,-10,-20,
    ],
    # King
    [
    -30,-40,-40,-50,-50,-40,-40,-30,
    -30,-40,-40,-50,-50,-40,-40,-30,
    -30,-40,-40,-50,-50,-40,-40,-30,
    -30,-40,-40,-50,-50,-40,-40,-30,
    -20,-30,-30,-40,-40,-30,-30,-20,
    -10,-20,-20,-20,-20,-20,-20,-10,
     20, 20,  0,  0,  0,  0, 20, 20,
     20, 30, 10,  0,  0, 10, 30, 20,
    ],
]


class BlueRose:
    def __init__(self):
        self.board = chess.Board()
        self.transposition_table = {}
        self.killer_heuristic_table = {}

    def board_evaluation_2(self):
        mobility = self.board.legal_moves.count()
        self.board.turn = not self.board.turn
        mobility_other = self.board.legal_moves.count()
        self.board.turn = not self.board.turn

        score = 100*(
            chess.popcount(self.board.pieces_mask(1, True))
            - chess.popcount(self.board.pieces_mask(1, False))
        ) + 300*(
            chess.popcount(self.board.pieces_mask(2, True))
            - chess.popcount(self.board.pieces_mask(2, False))
        ) + 300*(
            chess.popcount(self.board.pieces_mask(3, True))
            - chess.popcount(self.board.pieces_mask(3, False))
        ) + 500*(
            chess.popcount(self.board.pieces_mask(4, True))
            - chess.popcount(self.board.pieces_mask(4, False))
        ) + 900*(
            chess.popcount(self.board.pieces_mask(5, True))
            - chess.popcount(self.board.pieces_mask(5, False))
        ) + 10*(mobility - mobility_other)

        return score

    def board_evaluation(self):
        score = 0
        p_at = self.board.piece_at
        for square in chess.scan_reversed(self.board.occupied):
            piece = p_at(square)
            pt = piece.piece_type
            if pt == chess.KING and self.board.fullmove_number > MOVES_TO_ENDGAME:
                pt = 0

            if piece.color:
                sq = chess.square_mirror(square)
                score += POSITION_VALUES[pt][sq]
            else:
                sq = square
                score -= POSITION_VALUES[pt][sq]

        return score


    def negamax(self, depth, alpha, beta, time_limit):
        global nodes
        nodes += 1

        global kill_search
        if kill_search or time.time() > time_limit:
            return None, None

        alphaOrig = alpha

        zhash = chess.polyglot.zobrist_hash(self.board) #& (TRANSPOSITION_TABLE_SIZE - 1)
        ttEntry = self.transposition_table.get(zhash)
        if ttEntry and ttEntry[ttDEPTH] >= depth:
            if ttEntry[ttFLAG] == ttEXACT:
                return ttEntry[ttVALUE], None
            elif ttEntry[ttFLAG] == ttLOWERBOUND:
                alpha = max(alpha, ttEntry[ttVALUE])
            elif ttEntry[ttFLAG] == ttUPPERBOUND:
                beta = min(beta, ttEntry[ttVALUE])

            if alpha >= beta:
                return ttEntry[ttVALUE], None

        if self.board.is_checkmate():
            return -MAX_SCORE, None

        if self.board.is_stalemate():
            return 0, None

        if self.board.is_insufficient_material():
            return 0, None

        if self.board.is_repetition(3):
            return 0, None

        if depth == 0:
            score = self.board_evaluation()
            if not self.board.turn:
                score = -score

            return score, None

        best_score = -MAX_SCORE - 1

        killer = self.killer_heuristic_table.get(zhash)
        if not killer and depth > 2:
            _, killer = self.MTDf(depth - 3, alpha, time_limit)

        move_list = []
        if killer:
            move_list.append(killer)

        move_list.extend(self.board.generate_legal_captures())
        move_list.extend(self.board.generate_legal_moves())
        move_set = set()
        for move in move_list:
            if move in move_set:
                continue
            move_set.add(move)

            self.board.push(move)
            value, _ = self.negamax(depth - 1, -beta, -alpha, time_limit)
            self.board.pop()

            if value is None:
                return None, None

            value = -value
            if value > best_score:
                best_score, best_move = value, move

            alpha = max(best_score, alpha)
            if alpha >= beta:
                break

        new_ttEntry = [0, 0, 0]
        new_ttEntry[ttVALUE] = best_score
        if best_score <= alphaOrig:
            new_ttEntry[ttFLAG] = ttUPPERBOUND
        elif best_score >= beta:
            new_ttEntry[ttFLAG] = ttLOWERBOUND
        else:
            new_ttEntry[ttFLAG] = ttEXACT
        new_ttEntry[ttDEPTH] = depth
        self.transposition_table[zhash] = new_ttEntry
        self.killer_heuristic_table[zhash] = best_move

        return best_score, best_move

    def MTDf(self, depth, first_guess, time_limit):
        g = first_guess
        upperbound = MAX_SCORE
        lowerbound = -MAX_SCORE
        while lowerbound < upperbound:
            beta = max(g, lowerbound + 1)
            g, move = self.negamax(depth, beta - 1, beta, time_limit)

            if g is None:
                return None, None

            if g < beta:
                upperbound = g
            else:
                lowerbound = g

        return g, move

    def iterative_deepening(self, move_time, max_depth):
        self.transposition_table.clear()
        self.killer_heuristic_table.clear()

        t1 = time.time()
        time_limit = t1 + move_time
        color = [-1, 1][self.board.turn]

        best_move = list(self.board.legal_moves)[0]

        global nodes
        nodes = 0

        depth = 1
        first_guess = 0
        while True:
            first_guess, move = self.MTDf(depth, first_guess, time_limit)
            if first_guess is None:
                return best_move

            best_move = move

            time_ms = int((time.time() - t1) * 1000) + 1
            nps = int(nodes/time_ms * 1000)

            print(f'info depth {depth} multipv 1 score cp {color*first_guess} nodes {nodes} nps {nps} time {time_ms} pv {self.board.uci(best_move)}', flush=True)

            if abs(first_guess) == MAX_SCORE:
                return best_move

            depth += 1
            if max_depth > 0 and depth > max_depth:
                break

        return best_move

    def uci(self, command):
        if command == 'uci':
            print('id name BlueRose 1', flush=True)
            print('id author Brian Pomerantz', flush=True)
            print('uciok', flush=True)

        elif command == 'isready':
            print('readyok', flush=True)

        elif command == 'ucinewgame':
            self.board = chess.Board()

        elif 'position' in command:
            mi = -1
            if 'moves' in command:
                mi = command.index('moves') - 1
                fen = command[9:mi]
            else:
                fen = command[9:]

            if fen == 'startpos':
                fen = chess.STARTING_FEN

            self.board = chess.Board(fen)

            if mi != -1:
                moves_list = command[mi+1:].split()[1:]
                for move in moves_list:
                    move_obj = chess.Move.from_uci(move)
                    self.board.push(move_obj)

        elif 'go' in command:
            time_limit = 30*60
            depth = -1

            time_str = 'wtime' if self.board.turn else 'btime'
            if time_str in command:
                args = command.split()
                idx = args.index(time_str) + 1
                time_left = int(args[idx]) / 1000
                time_denom = MOVES_TO_ENDGAME
                if self.board.fullmove_number < 10:
                    time_denom *= 1.5
                time_limit = time_left // time_denom

            elif 'movetime' in command:
                time_limit = command.split()[2]
                time_limit = int(time_limit) // 1000 - 3

            elif 'depth' in command:
                depth = int(command.split()[2])

            move = self.iterative_deepening(time_limit, depth)
            print(f'bestmove {self.board.uci(move)}', flush=True)
            global kill_search
            kill_search = False


if __name__ == '__main__':
    print('BlueRose 1 by Brian Pomerantz', flush=True)
    engine = BlueRose()
    global kill_search
    kill_search = False

    for i in range(1, 6):
        for sq in range(64):
            POSITION_VALUES[i][sq] += PIECE_VALUES[i]

    if len(sys.argv) == 2 and sys.argv[1] == 'test':
        engine.uci('go depth 8')
        exit()

    while True:
        uci_input = input()
        if uci_input == 'stop':
            kill_search = True
            continue
        if uci_input == 'quit':
            break
        x = threading.Thread(target=engine.uci, args=(uci_input,), daemon=True)
        x.start()
